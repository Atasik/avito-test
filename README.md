# Запуск
Для работы приложения нужен .env файл, который выглядит так:
`````````
POSTGRES_PASSWORD=qwerty
POSTGRES_USER=postgres
POSTGRES_PORT=5432
POSTGRES_HOST=postgresdb

HTTP_HOST=localhost
`````````

Запуск приложения:
````````
make run
````````

# Curl-запросы:

1. Беру историю за август 2023 года
curl -X 'POST' \
  'http://localhost:8080/api/user/history' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "id": 1,
  "period": "2023-08"
}'

2. Смотрю сегменты 1-ого пользователя
curl -X 'POST' \
  'http://localhost:8080/api/user' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "id": 1
}'

3. Добавляю user'а с id=4 и одним сегментом
curl -X 'POST' \
  'http://localhost:8080/api/segment/user' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "id": 4,
  "segmentsToAdd": [
    {
      "expired_at": "2024-08-27",
      "name": "AVITO_VOICE_MESSAGES"
    }
  ]
}'

4. Добавляю сегмент AVITO_TEST с процентом распределения 25%
curl -X 'POST' \
  'http://localhost:8080/api/segment' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "name": "AVITO_TEST",
  "percentage": 0.25
}'

5. Удаление сегмента AVITO_TEST
curl -X 'DELETE' \
  'http://localhost:8080/api/segment' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "name": "AVITO_TEST"
}'

# Почему я сделал так, а не по-другому?

1. Почти все запросы POST, почему?
``````
Сервис должен предоставлять HTTP API с форматом JSON как при отправке запроса, так и при получении результата.
``````
С GET запросом я тело запроса не отправлю. Как я понял задание, общение должно быть чисто на JSON

2. CSV создание в файл вынесено в репозиторий, почему?
Т.к. я старался придерживаться хоть как-то чистой архитектуры, я понял, что по-другому оформить это не получится (+ прокинуть зависимости).
В истории коммитов можно посмотреть, как я сделал это до этого

3. Почему использовал триггеры и почему они в sql файле?
По моему мнению использовать в данной задаче что-то кроме триггеров нецелесообразно, т.к. придётся при расширении (потенциальном) приложения
прописывать на новые insert'ы какие-нибудь заново внесение в историю. Сами триггеры хотел вынести в начало инициализации программы, но в итоге
передумал, т.к. разницы особой, как мне кажется, нет.

4. Почему такой формат времени?
Если говорить про получение истории, то я опирался на данное описание в самом задании:
`````````
На вход: год-месяц. На выходе ссылка на CSV файл.
`````````
Как можно увидеть, говорится о формате год-месяц. Собственно от него я и отталкивался.
Времени в поле expired_at нет, т.к. вводить это неудобно. К тому же, я не уверен, что при реальной раздаче сегментов это критически важно.

5. Почему сделал вызов базы данных из main'а в интервале времени?
Я прикинул два варианта: чистить бд на каждом вызове получения сегментов или интервал.
В продакшене метод получения сегментов почти наверняка будет вызываться очень часто, а значит и условная горутина, которая будет
всё чистить тоже будет запускаться часто, как и осуществляться вызов БД, что в теории может плохо сказаться на производительности
БД и приложения. Поэтому я взял интервал. 30 секунд интервал из-за данного условия:
`````````
мы должны получить АКТУАЛЬНУЮ информацию о сегментах пользователя с задержкой не более 1 минуты после добавления сегмента.
`````````
